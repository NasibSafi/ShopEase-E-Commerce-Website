# ShopEase E-Commerce Website

This is a group project for WOC7014 FRAMEWORK-BASED SOFTWARE DESIGN AND DEVELOPMENT

# Group J

| Name         | Metric number |
| ------------ | ------------- |
| Nasib Ullah  | S2019652      |
| Hilman Hilmi | 22073279      |
| Yuhuan He    | S2165922      |
| Liu JiaLiang | S2180651      |
| Jie Jiang    | S2183694      |

<img src="ShopEase-E-Commerce-Website\ShopEase\app\static\images\ShopEase.jpg" width="1000">

## Project Instruction

1. ShopEase E-Commerce Website
2. Functional modules: user module (registration/login/activation/exit/personal center/address), goods module (homepage/details/list/search), cart module (add/delete/modify/query), order module (submit order /request payment/query payment result/comment)
3. django default authentication system **AbstractUser**
   - The user data generated by create_user() by default, is_active=1, is the activated state. You need to set is_active to 0 to create an inactive user manually.
4. itsdangerous Generate signed token (encrypted)
5. Mail django provides mail support configuration parameter send_mail
6. celecy asynchronous task
7. page static
8. cache
9. Minio distributed file storage service, modified django's default file storage system
10. Rich text editor- **[django-simditor](https://github.com/istommao/django-simditor)**
11. Search (whoosh index word segmentation)

## Demand Analysis

### User Modules

1. Registration Page
   - Checking whether the user name has been registered during registration
   - Complete the registration of user information
   - Send an email to the user's registered email address and click on the activation link in the email to complete the activation of the user's account
2. Login page
   - Implement user login function
3. User Center
   - User center information page: displays the login user's information, including user name, phone number and address, while the bottom of the page displays the user's recently viewed product information
   - User center address page: display the default delivery address of the logged-in user, and the form at the bottom of the page can add the user's delivery address
   - User center order page: display the order information of the logged-in user
4. Other
   - If the user is logged in, the user's information is displayed at the top of the page

### Goods Module

1. Home page
   - Dynamic designation of home page rotating image product information
   - Dynamically specify home page activity information
   - Dynamically obtain the product category information and display it
   - Dynamically specify each type of product (including image products and text products) displayed on the home page
   - Jump to the product details page when clicking on a product
2. Product details page
   - Displays the details of a product
   - The bottom left of the page shows 2 new products of that category.
3. Product list page
   - Displays a list of products of a certain category, paginated and sorted by default/price/popularity
   - The bottom left of the page shows the information of 2 new products of the category
4. Other
   - Search the product information through the search box on the page

### Shopping Cart Related

- List page and detail page to add products to cart
- After the user logs in, the number of products in the shopping cart of the logged-in user is displayed on the home page, details page, and list page.
- Shopping cart page, the operation of the products in the user's shopping cart, such as selecting a product, increasing or decreasing the number of products in the shopping cart

### Order Related

- Submit order page, displaying information about the product the user is ready to purchase
- Click Submit Order to complete the order creation
- User center order page shows the user's order information
- Click on Pay to complete the order payment

## Project Structure

- mysql Database
- redis（Cache Server，session）
- celery （Asynchronous task processing）
- Minio（Distributed File Storage System）

##

### redis Implementation of shopping cart function

1. When do I add a shopping cart record?
   - Shopping cart records are added when users click Add to Cart
2. When do I need to retrieve cart records?
   - You need to get the cart records when you use the data in the shopping cart and the shopping cart page.
3. What is the format for analyzing the cart records?
   - A user's shopping cart record is stored in one data
   - `hash` card_user_id : { sku_id1:number of items,sku_id2:number of items }
   - `"cart_1":{"1":3, "2":5}` => cart records added by a user with id 1: 3 items added by item id 1, 5 items added by item id 2
   - Get the number of items in the user's shopping cart: `HLEN`

### redis Save user browsing history

1. When do I need to add history?  
   _When you visit the product details page (in the view corresponding to the product details), you need to add the history of your browsing history_.
2. When do I need to get the browsing history?
   \*When accessing the user's personal information.
3. What is the format for storing history in redis?

   Each user's browsing history is stored as one piece of data, using the List type \*
   user id:[product id,...]
   When adding a history, the id of the latest product viewed by the user is inserted from the left side of the list

##

- django Built-in functions to send emails

  ```python
  from django.core.mail import send_mail

  send_mail('send_header','send_body','sender','recipient_list',html_message='send_body(HTML format)')
  ```

  ```python
  # settings.py Configuration for sending emails
  EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
  EMAIL_HOST = 'smtp.qq.com' # smtp service address
  EMAIL_PORT = 587 # smtp service port
  EMAIL_HOST_USER = 'xxx@qq.com' # sender email
  EMAIL_HOST_PASSWORD = '' # authorization code
  ```

- celery asynchronous tasks

  - Suitable for asynchronous processing problems, when sending emails, or uploading files, image processing and some other time-consuming operations, we can execute them asynchronously, so that users do not need to wait for a long time

  - Simple, easy to use and maintain, with rich documentation; efficient, a single celery process can handle millions of tasks per minute; flexible, almost every part of celery can be custom extended

  - Start celery:

    celery -A celery_tasks.tasks worker --loglevel=info -P eventlet -c 10

- Login Decorator [login_required](https://docs.djangoproject.com/zh-hans/4.0/topics/auth/default/#the-login-required-decorator)

- `request.user` Any request over, request will generate user information user, if not logged in is an instance of the `AnonymousUser` class; if logged in is an instance of the `AUTH_USER_MODEL` class, can be distinguished by `is_authenticated`

```python
# Defining the model abstract base class
from django.db import models
class BaseModel(models.Model):
    create_time = models.DateTimeField(auto_now_add=True,verbose_name='Creation time')
    update_time = models.DateTimeField(auto_add=True,verbose_name='Update time')
    is_del = models.BooleanField(default=False,verbose_name='is_del')

    class Meta:
        abstract = True
```

### Concurrency problem (pessimistic lock, optimistic lock)

If there is only one item in stock and more than one person places an order for that item at the same time, there may be a problem that the item has been purchased by one person, but the number of items in stock still exists when other people place orders, which is a concurrency problem

- Solved by pessimistic locking: the first time the data of the product is queried, a lock is added until the end of the transaction, the lock is released, and the purchase is successful or failed, otherwise, other people will be waiting for the order.
- Solved by optimistic locking: everyone buys the item at the same time, and when placing an order to change the inventory, determine whether the inventory is the same as the original inventory queried, if it is, the purchase is considered successful, otherwise the inventory has changed and multiple attempts are needed; the process of placing an order will not be blocked waiting
- Use optimistic locks when there are fewer conflicts

#### Pessimistic lock (locking when querying access data)

Lock is added when querying data until the transaction ends and the lock is released, otherwise all other sql statements are blocked

- SQL ： `select * from f_goods_sku where id=17 for update` (for update locking), the transaction ends and the lock is released
- Django ： `GoodsSKU.objects.select_for_update().get(id=17)`

#### Optimistic lock (judge whether the data is consistent when updating data)

No lock is added when querying the data, and a judgment is made when updating the data to determine whether the inventory at the time of update is the same as the inventory previously checked out.

**Assuming that the stock inventory queried is 1**

- SQL ： `update f_goods_sku set stock=0,sales=1 where id=17 and stock=1` (Set inventory-1 and determine whether the inventory is equal to the queried inventory1)
- Django
  ```python
  sku = GoodsSKU.objects.get(id=17)
  origin_stock = sku.stock
  new_stock = origin_stock - int(count) # new_stock = the number of stocks found - the number to buy
  new_sales = sku.sales + int(count) # new_sales
  # update() returns the number of affected rows
  res = GoodsSKU.objects.filter(id=17,stock=origin_stock).update(stock=new_stock,sales=new_sales)
  if res == 0.
      """The update method returns 0 only proves that the data has been changed, and does not indicate that the current product is out of stock, so you need to try multiple times to query & update """
      transaction.savepoint_rollback(save_id) # Transaction rollback
      return "failed"
  ```
  - Need to set the isolation level of mysql transaction (read commits)
    - mysql configuration file add or modify: `transaction-isolation = READ-COMMITTED`
    - After django 2.x it seems that the transaction isolation level has been changed to READ-COMMITTED

### Page Static (Index)

1. generate static files asynchronously via celery
2. if the celery service and django service is not on the same machine, through the configuration of nginx access to the static file
3. send a command through celery to regenerate the index static page when the backend admin updates the home page data table
   - `ModelAdmin` method [admin admin site](https://docs.djangoproject.com/zh-hans/4.0/ref/contrib/admin/#modeladmin-methods)
     - `save_model()` method: called when the backend admin adds or updates the data in the table
     - `delete_model()` method: called when the backend admin deletes the data in the table

### Caching of page data

[CACHES](https://docs.djangoproject.com/zh-hans/4.0/topics/cache/)
CACHES configuration items in **settings.py**

1. set cache (Memcached, Redis, database cache, file system cache, local memory cache)
2. Cache method
   - Site cache (cache the whole site)
   - View caching (cache view results)
   - Template fragment caching (cache fragment content)
   - Underlying caching API (cache any Python object that can be safely pickedle)
3. When the backend administration modifies the home page information data, it needs to update the home page cache data

```python
from django.core.cache import cache

cache.set('my_key', 'hello, world!', 30)
cache.get('my_key')
cache.delete('my_key')
```

####

## Project Start

### Prerequisites

1. Installation Django `pip install django` 4.0.4
2. Installation pymysql `pip install pymysql` 1.0.2
3. Installation django-simditor Rich Text Editor

   ```
   pip install django-simditor
   ```

4. Installation itsdangerous 加密模块 `pip install itsdangerous` 2.1.2
5. Installation celery `pip install -U Celery` 5.2.7
6. Installation redis `pip install redis` 4.3.1
7. Installation django-redis `pip install django-redis` 5.2.0
8. Installation alipay-sdk-python `pip install alipay-sdk-python` 3.6.598
9. Installation django-minio-storage

   ```
   pip install django-minio-storage==0.5.3
   ```

## Launch Project

1. Run Redis

   Installation redis for windows and start it

2. Run celery

   Run celery under the second terminal

   ![image-20230524203813788](C:\Users\aw\AppData\Roaming\Typora\typora-user-images\image-20230524203813788.png)

   ```
   celery -A celery_tasks.tasks worker --loglevel=info -P eventlet -c 10
   ```

3. Run minio

   1. Using python to interact with Minio [Minio_server_Windows](https://min.io/download#/windows)

      1. ![image-20230524201340223](C:\Users\aw\AppData\Roaming\Typora\typora-user-images\image-20230524201340223.png)

      2. ```python
         pip install django-minio-storage==0.5.3
         ```

      3. ```python
         #settings.py add
         #Set Django's file storage class
         DEFAULT_FILE_STORAGE = "minio_storage.storage.MinioMediaStorage"
         MINIO_STORAGE_ENDPOINT = '127.0.0.1:9000'
         MINIO_STORAGE_ACCESS_KEY = 'qXGziNImYjUHetKMNxLA'
         MINIO_STORAGE_SECRET_KEY = '5C5R5NCUS2zZ77yrmRxUZg8xGHv2CKQ8XEN2zQXW'
         MINIO_STORAGE_USE_HTTPS = False
         MINIO_STORAGE_MEDIA_OBJECT_METADATA = {"Cache-Control": "max-age=1000"}
         MINIO_STORAGE_MEDIA_BUCKET_NAME = 'local-media'
         MINIO_STORAGE_MEDIA_BACKUP_BUCKET = 'Recycle Bin'
         MINIO_STORAGE_MEDIA_BACKUP_FORMAT = '%c/'
         MINIO_STORAGE_AUTO_CREATE_MEDIA_BUCKET = True
         MINIO_STORAGE_STATIC_BUCKET_NAME = 'local-static'
         MINIO_STORAGE_AUTO_CREATE_STATIC_BUCKET = True
         ```

      4. Run the downloaded minio server

         ![image-20230524204321960](C:\Users\aw\AppData\Roaming\Typora\typora-user-images\image-20230524204321960.png)

         ```
         1.cmd
         2.minio.exe server E:\minio\data
         ```

4. Run project

   1. First, configure the database in settings.py

   2. After that, execute the migration command

   ```
   python manage.py makemigrations
   ```

   ```
   python manage.py migrate
   ```

   3. ```
      python manage.py runserver
      ```

   ```


   ```
